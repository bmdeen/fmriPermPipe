
% Function to apply motion and distortion correct, and registration to
% functional template with a single interpolation step.
%
% Assumes matched naming between input and mcDir.
%
% TODO: Add option to change short/long descriptions

function oneShotMotionDistortionCorrect(inputPaths,outputPaths,funcTemplatePath,funcTemplateName,mcDir,topupWarpPath,...
    topupJacobianPath,xfmNativeFunc2FuncTemplate,xfmSpinEcho2NativeFunc,xfmNativeFunc2SpinEcho,echoForMoCorr)

xfmSpinEcho2FuncTemplate = fpp.bids.changeName(topupJacobianPath,{'desc','from','to','mode'},...
    {'','orig',funcTemplateName,'image'},'xfm','.mat');
topupJacobian2FuncTemplatePath = fpp.bids.changeName(topupJacobianPath,'space',funcTemplateName,'jacobian');
[~,mcName,~] = fileparts(mcDir);

% Move warp Jacobian to FuncTemplate space
fpp.fsl.concatXfm(xfmNativeFunc2FuncTemplate,xfmSpinEcho2NativeFunc,xfmSpinEcho2FuncTemplate);
fpp.fsl.moveImage(topupJacobianPath,funcTemplatePath,topupJacobian2FuncTemplatePath,xfmSpinEcho2FuncTemplate);

% Check # of volumes
vols = fpp.util.checkMRIProperty('vols',inputPaths{1});
tr = fpp.util.checkMRIProperty('tr',inputPaths{1});

for e=1:length(outputPaths)
    mergeCmd = ['fslmerge -tr ' outputPaths{e}];
    inputSplitStem = [strrep(inputPaths{e},'.nii.gz','') '_SplitForMoco'];
    outputSplitStem = [strrep(fpp.bids.changeName(inputPaths{e},'space',funcTemplateName),'.nii.gz','') '_SplitForMoco'];
    fpp.util.system(['fslsplit ' inputPaths{e} ' ' inputSplitStem ' -t']);
    for t=0:vols-1
        inputVolPath = [inputSplitStem fpp.util.numPad(t,4) '.nii.gz'];
        outputVolPath = [outputSplitStem fpp.util.numPad(t,4) '.nii.gz'];
        fpp.fsl.concatXfm(xfmNativeFunc2FuncTemplate,xfmSpinEcho2NativeFunc,xfmSpinEcho2FuncTemplate);
        xfmInputVol2NativeFunc = [mcDir '/' fpp.bids.changeName(mcName,{'echo','desc','from','to','mode'},...
            {int2str(echoForMoCorr),'',['orig' fpp.util.numPad(t,4)],'orig','image'},'xfm','.mat')];
        xfmInputVol2SpinEcho = [mcDir '/' fpp.bids.changeName(mcName,{'echo','desc','from','to','mode'},...
            {int2str(echoForMoCorr),'',['orig' fpp.util.numPad(t,4)],'SpinEcho','image'},'xfm','.mat')];
        fpp.fsl.concatXfm(xfmNativeFunc2SpinEcho,xfmInputVol2NativeFunc,xfmInputVol2SpinEcho);
        fpp.fsl.moveImage(inputVolPath,funcTemplatePath,outputVolPath,xfmInputVol2SpinEcho,...
            'warp',topupWarpPath,'postmat',xfmSpinEcho2FuncTemplate);
        fpp.util.system(['fslmaths ' outputVolPath ' -mul ' topupJacobian2FuncTemplatePath ' ' outputVolPath]);
        mergeCmd = [mergeCmd ' ' outputVolPath];
        if mod(t+1,10)==0
           fprintf('\t%s\n',['Finished warping echo ' int2str(e) ', volume ' int2str(t+1)]);
        end
    end
    
    % Merge output into single time series file, delete individual time points
    mergeCmd = [mergeCmd ' ' num2str(tr)];
    fpp.util.system(mergeCmd);
    fpp.util.system(['rm -rf ' inputSplitStem '*.nii.gz ' outputSplitStem '*.nii.gz']);
    
    % Generate output JSON file
    fpp.bids.jsonReconstruct(inputPaths{e},outputPaths{e});
    fpp.bids.jsonChangeValue(outputPaths{e},{'Description','Sources','SpatialReference'},...
        {['Partially preprocessed data generated by fmriPermPipe, saved after motion correction, '...
        ' distortion, and functional template registration step.'],...
        fpp.bids.removeBidsDir(inputPaths{e}),funcTemplateName});
end

end