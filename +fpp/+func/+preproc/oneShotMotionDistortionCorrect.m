
% Function to apply motion and distortion correct, and registration to
% functional template with a single interpolation step.
%
% Assumes matched naming between input and mcDir.

function oneShotMotionDistortionCorrect(inputPaths,outputPaths,funcTemplatePath,funcTemplateName,mcDir,topupWarpPath,...
    topupJacobianPath,xfmNativeFunc2FuncTemplate,xfmSpinEcho2NativeFunc,xfmNativeFunc2SpinEcho,echoForMoCorr)

xfmSpinEcho2FuncTemplate = fpp.bids.changeName(topupJacobianPath,{'desc','from','to','mode'},...
    {'','orig',funcTemplateName,'image'},'xfm','.mat');
topupJacobian2FuncTemplatePath = fpp.bids.changeName(topupJacobianPath,'space',funcTemplateName,'jacobian');
[~,mcName,~] = fileparts(mcDir);

% Move warp Jacobian to FuncTemplate space
system(['convert_xfm -omat ' xfmSpinEcho2FuncTemplate ' -concat ' xfmNativeFunc2FuncTemplate ' ' xfmSpinEcho2NativeFunc]);
system(['flirt -in ' topupJacobianPath ' -ref ' funcTemplatePath ' -out ' topupJacobian2FuncTemplatePath ...
    ' -applyxfm -init ' xfmSpinEcho2FuncTemplate]);

% Check # of volumes
[~,vols] = system(['fslval ' inputPaths{1} ' dim4']);
vols = str2num(strtrim(vols));
tr = fpp.util.checkMRIProperty('tr',inputPaths{1});

for e=1:length(outputPaths)
    mergeCmd = ['fslmerge -tr ' outputPaths{e}];
    inputSplitStem = [strrep(inputPaths{e},'.nii.gz','') '_SplitForMoco'];
    outputSplitStem = [strrep(fpp.bids.changeName(inputPaths{e},'space',funcTemplateName),'.nii.gz','') '_SplitForMoco'];
    system(['fslsplit ' inputPaths{e} ' ' inputSplitStem ' -t']);
    for t=0:vols-1
        inputVolPath = [inputSplitStem fpp.util.numPad(t,4) '.nii.gz'];
        outputVolPath = [outputSplitStem fpp.util.numPad(t,4) '.nii.gz'];
        system(['convert_xfm -omat ' xfmSpinEcho2FuncTemplate ' -concat ' xfmNativeFunc2FuncTemplate ' ' xfmSpinEcho2NativeFunc]);
        xfmInputVol2NativeFunc = [mcDir '/' fpp.bids.changeName(mcName,{'echo','desc','from','to','mode'},...
            {int2str(echoForMoCorr),'',['orig' fpp.util.numPad(t,4)],'orig','image'},'xfm','.mat')];
        xfmInputVol2SpinEcho = [mcDir '/' fpp.bids.changeName(mcName,{'echo','desc','from','to','mode'},...
            {int2str(echoForMoCorr),'',['orig' fpp.util.numPad(t,4)],'SpinEcho','image'},'xfm','.mat')];
        system(['convert_xfm -omat ' xfmInputVol2SpinEcho ' -concat ' xfmNativeFunc2SpinEcho ' ' xfmInputVol2NativeFunc]);
        % Single-shot application of motion correction, undistortion, and registration to FuncTemplate
        system(['applywarp --in=' inputVolPath ' --ref=' funcTemplatePath ' --out=' outputVolPath ...
            ' --warp=' topupWarpPath ' --premat=' xfmInputVol2SpinEcho ' --postmat=' xfmSpinEcho2FuncTemplate]);
        system(['fslmaths ' outputVolPath ' -mul ' topupJacobian2FuncTemplatePath ' ' outputVolPath]);
        mergeCmd = [mergeCmd ' ' outputVolPath];
        if mod(t+1,10)==0
           fprintf('\t%s\n',['Finished warping echo ' int2str(e) ', volume ' int2str(t+1)]);
        end
    end
    
    % Merge output into single time series file, delete individual time points
    mergeCmd = [mergeCmd ' ' num2str(tr)];
    system(mergeCmd);
    system(['rm -rf ' inputSplitStem '*.nii.gz ' outputSplitStem '*.nii.gz']);
    
    % Generate output JSON file
    [~,~,inputExt] = fpp.util.fileParts(inputPaths{e});
    inputJsonPath = strrep(inputPaths{e},inputExt,'.json');
    [~,~,outputExt] = fpp.util.fileParts(outputPaths{e});
    outputJsonPath = strrep(outputPaths{e},outputExt,'.json');
    fpp.bids.jsonReconstruct(inputJsonPath,outputJsonPath);
    bidsBaseDir = fpp.bids.checkBidsDir(inputPaths{e});
    sources = inputPaths{e};
    if ~isempty(bidsBaseDir)
        sources = strrep(sources,bidsBaseDir,'');
    end
    fpp.bids.jsonChangeValue(outputJsonPath,{'Description','Sources','SpatialReference'},...
        {['Partially preprocessed data generated by fmriPermPipe, saved after motion correction, '...
        ' distortion, and functional template registration step.'],...
        sources,funcTemplateName});
end

end