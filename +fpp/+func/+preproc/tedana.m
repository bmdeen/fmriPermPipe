
% Wrapper for tedana and t2smap; renames outputs based on input name, and
% generates JSON metadata for outputs.
%
% fpp.func.preproc.tedana(inputPaths,outputPaths,maskPath,outputDescription,useTedana)
%
% Arguments:
%   - inputPaths (cell array of strings): paths to input images for each
%     echo
%   - outputPath (string): path to output image
%
% Optional arguments:
%   - outputDescription (string): contents of output json Description field
%   - useTedana (boolean): whether to use tedana or just t2smap
%   - teVals (vector of values in (0,Inf)): TE values (ms) for multi-echo 
%       data (default: read from json)
%
% Variable arguments:
% - tedPCA (string): tedpca input, determines method for PCA comp
%       selection. Options: mdl, kic, aic (more to less aggressive)
% - manAcc (vector of integers in [0,Inf)): components to manually accept,
%       if re-running

function tedana(inputPaths,outputPath,maskPath,outputDescription,useTedana,teVals,varargin)

% Process optional arguments
if ~exist('useTedana','var') || isempty(useTedana)
    useTedana = 1;
end
if ~exist('outputDescription','var')
    outputDescription = '';
end
if ~exist('teVals','var') || isempty(teVals)
    teVals = fpp.util.checkMRIProperty('TE',inputPaths{1});
end

% Variable arguments
tedPCA = 'mdl';                 % tedpca input, method to select components. Options: mdl, kic, aic
manAcc = [];                    % Components to manually accept, if rerunning.

% Edit variable arguments.  Note: optInputs checks for proper input.
varArgList = {'tedPCA','manAcc'};
for i=1:length(varArgList)
    argVal = fpp.util.optInputs(varargin,varArgList{i});
    if ~isempty(argVal)
        eval([varArgList{i} ' = argVal;']);
    end
end

% Check output directory, add _bold.nii.gz if missing
[outputDir,outputName,~] = fpp.util.fileParts(outputPath);
if isempty(outputDir), outputDir = pwd; end
if ~strcmp(outputName(end-4:end),'_bold')
    outputName = [outputName '_bold'];
end
outputExt = '.nii.gz';
outputPath = [outputDir '/' outputName outputExt];
[~,inputName,~] = fpp.util.fileParts(inputPaths{1});

% Place output in temporary directory to delete extra results
outputDir = [outputDir '/tedanaTmp' inputName];
if exist(outputDir,'dir'), fpp.util.system(['rm -rf ' outputDir]); end
mkdir(outputDir);

% Define wrapper function for fpp.bids.removeBidsDir (for cellfun functionality)
removeBidsDir = @(x) fpp.bids.removeBidsDir(x);

if useTedana
    
    % Define i/o variables
    if isempty(outputDescription)
        outputDescription = 'Partially preprocessed data generated by fmriPermPipe, saved after TEDANA denoising step.';
    end
    inputPathStr = join(inputPaths,' ');
    
    % Run tedana
    fpp.util.system(['tedana -d ' inputPathStr{1} ' -e ' sprintf('%f ',teVals) ' --out-dir ' ...
        outputDir ' --mask ' maskPath ' --verbose --tedpca ' tedPCA]);
    
    % Create output directory
    outputDirTedana = strrep(fpp.bids.changeName(outputPath,{'desc'},{[]}),'_bold.nii.gz','_tedana');
    fpp.util.system(['mkdir ' outputDirTedana]);
    outputPathTedana = [outputDirTedana '/' outputName outputExt];
    
    % Rerun tedana with manually accepted components, if specified
    if ~isempty(manAcc)
        fpp.util.system(['mv ' outputDir '/tedana_report.html ' fpp.bids.changeName(outputPathTedana,...
            'desc','tedanaICAFirstPass','report','.html')]);
        fpp.util.system(['tedana -d ' inputPathStr{1} ' -e ' sprintf('%f ',teVals) ' --out-dir ' ...
            outputDir ' --mask ' maskPath ' --verbose --mix ' outputDir '/desc-ICA_mixing.tsv '...
            '--ctab ' outputDir '/desc-ICA_decomposition.json --manacc ' int2str(manAcc)]);
    end
    
    % Rename main outputs
    fpp.util.system(['mv ' outputDir '/T2starmap.nii.gz ' strrep(outputPathTedana,'_bold.nii.gz','_T2star.nii.gz')]);
    fpp.util.system(['mv ' outputDir '/S0map.nii.gz ' strrep(outputPathTedana,'_bold.nii.gz','_S0map.nii.gz')]);
    fpp.util.system(['mv ' outputDir '/desc-optcomDenoised_bold.nii.gz ' outputPath]);
    fpp.util.system(['mv ' outputDir '/desc-optcom_bold.nii.gz ' fpp.bids.changeName(outputPath,'desc','midprep4optcomb')]);
    fpp.util.system(['mv ' outputDir '/figures ' outputDirTedana '/figures']);
    fpp.util.system(['mv ' outputDir '/tedana_report.html ' fpp.bids.changeName(outputPathTedana,'desc','tedanaICA','report','.html')]);
    
    % Define main json file
    fpp.bids.jsonReconstruct(inputPaths{1},outputPath,'midprepfmri');
    fpp.bids.jsonChangeValue(outputPath,{'Description','Sources','EchoTime','EchoNumber'},...
        {outputDescription,cellfun(removeBidsDir,inputPaths,'UniformOutput',false),teVals/1000,[]});
    % Define non-denoised json file
    fpp.bids.jsonReconstruct(inputPaths{1},fpp.bids.changeName(outputPath,'desc','midprep4optcomb'),'midprepfmri');
    fpp.bids.jsonChangeValue(fpp.bids.changeName(outputPath,'desc','midprep4optcomb'),{'Sources','EchoTime','EchoNumber'},...
        {cellfun(removeBidsDir,inputPaths,'UniformOutput',false),teVals/1000,[]});
    
    % Rename component analysis results outputs
    logFiles = dir([outputDir '/tedana_*.tsv']);    % If manacc was specified, two log files will exist
    if length(logFiles)==1, logNames = {'tedanaICA'};
    else logNames = {'tedanaICAFirstPass','tedanaICA'}; end
    for f=1:min(length(logFiles),2)
        fpp.util.system(['mv ' outputDir '/' logFiles(f).name ' ' fpp.bids.changeName(outputPathTedana,'desc',logNames{f},'log','.tsv')]);
    end
    fpp.util.system(['mv ' outputDir '/desc-ICA_components.nii.gz ' fpp.bids.changeName(outputPathTedana,'desc','tedanaICA')]);
    methods = {'PCA','ICA'}; suffices = {'stat-z_components','decomposition','mixing','metrics','metrics'};
    componentExts = {'.nii.gz','.json','.tsv','.json','.tsv'};
    for m=1:length(methods)
        for s=1:length(suffices)
            inputMethod = methods{m};
            if strcmp(suffices{s},'metrics') && strcmp(methods{m},'ICA')
                inputMethod = 'tedana';
            end
            fpp.util.system(['mv ' outputDir '/desc-' inputMethod '_' suffices{s} componentExts{s} ' ' ...
                fpp.bids.changeName(outputPathTedana,'desc',['tedana' methods{m}],suffices{s},componentExts{s})]);
        end
    end
    
    % Save rejected component mixing matrix (output data time series are orthogonal to these components)
    % Analysis may use these components as nuisance regressors
    mixPath = fpp.bids.changeName(outputPathTedana,'desc','tedanaICA','mixing','.tsv');
    mixPathOut = fpp.bids.changeName(outputPathTedana,'desc','tedanaICARejected','mixing','.tsv');
    metricsPath = fpp.bids.changeName(outputPathTedana,'desc','tedanaICA','metrics','.tsv');
    mixTSV = bids.util.tsvread(mixPath);
%     metrics = bids.util.tsvread(metricsPath);
    metrics = dsv_read(metricsPath);    % TEMPORARY for v0.0.12. Bug fix for lack of "rationale" entry for accepted components
    % Remove non-rejected components from mixTSV
    for i=1:length(metrics.Component)
        if ~strcmpi(metrics.classification{i},'rejected')
            mixTSV = rmfield(mixTSV,metrics.Component{i});
        end
    end
    bids.util.tsvwrite(mixPathOut,mixTSV);
    
else
    
    % Define i/o variables
    if isempty(outputDescription)
        outputDescription = ['Partially preprocessed data generated by fmriPermPipe, '...
            ' saved after multi-echo combination step.'];
    end
    inputPathStr = join(inputPaths,' ');
    
    % Run t2smap
    fpp.util.system(['t2smap -d ' inputPathStr{1} ' -e ' sprintf('%f ',teVals) ' --out-dir ' ...
        outputDir ' --mask ' maskPath]);
    
    % Rename outputs
    fpp.util.system(['mv ' outputDir '/desc-full_T2starmap.nii.gz ' strrep(outputPath,'_bold.nii.gz','_T2star.nii.gz')]);
    fpp.util.system(['mv ' outputDir '/desc-full_S0map.nii.gz ' strrep(outputPath,'_bold.nii.gz','_S0map.nii.gz')]);
    fpp.util.system(['mv ' outputDir '/desc-optcom_bold.nii.gz ' outputPath]);
    
    % Define main json file
    fpp.bids.jsonReconstruct(inputPaths{1},outputPath,'midprepfmri');
    fpp.bids.jsonChangeValue(outputPath,{'Description','Sources','EchoTime','EchoNumber'},...
        {outputDescription,cellfun(removeBidsDir,inputPaths,'UniformOutput',false),teVals/1000,[]});
    
end
    
% Delete unneeded results
fpp.util.system(['rm -rf ' outputDir]);

end

% Temporarily including a modified dsv_read from bids-matlab, to read
% metrics.tsv file that lacks entries in the "rationale" column for
% accepted components (v0.0.12)
function x = dsv_read(filename, delim, header)

  % Read delimiter-separated values file into a structure array
  % * header line of column names will be used if detected
  % * 'n/a' fields are replaced with NaN

  % -Input arguments
  % --------------------------------------------------------------------------
  if nargin < 2
    delim = '\t';
  end
  if nargin < 3
    header = true;
  end % true: detect, false: no
  delim = sprintf(delim);
  eol = sprintf('\n'); %#ok<SPRINTFN>

  % -Read file
  % --------------------------------------------------------------------------
  S = fileread(filename);
  if isempty(S)
    x = [];
    return
  end
  if S(end) ~= eol
    S = [S eol];
  end
  S = regexprep(S, {'\r\n', '\r', '(\n)\1+'}, {'\n', '\n', '$1'});

  % -Get column names from header line (non-numeric first line)
  % --------------------------------------------------------------------------
  h = find(S == eol, 1);
  hdr = S(1:h - 1);
  var = regexp(hdr, delim, 'split');
  N = numel(var);
  n1 = isnan(cellfun(@str2double, var));
  n2 = cellfun(@(x) strcmpi(x, 'NaN'), var);
  if header && any(n1 & ~n2)
    hdr = true;
    try
      var = genvarname(var); %#ok<DEPGENAM>
    catch
      var = matlab.lang.makeValidName(var, 'ReplacementStyle', 'hex');
      var = matlab.lang.makeUniqueStrings(var);
    end
    S = S(h + 1:end);
  else
    hdr = false;
    fmt = ['Var%0' num2str(floor(log10(N)) + 1) 'd'];
    var = arrayfun(@(x) sprintf(fmt, x), (1:N)', 'UniformOutput', false);
  end

  % -Parse file
  % --------------------------------------------------------------------------
  if exist('OCTAVE_VERSION', 'builtin') % bug #51093
    S = strrep(S, delim, '#');
    delim = '#';
  end
  if ~isempty(S)
    d = textscan(S, '%s', 'Delimiter', delim);
  else
    d = {[]};
  end

  % TEMP bug fix: add 'N/A' after 'accepted' to fill rationale field
  acceptInd = [];
  for i=1:length(d{1})
    if strcmpi(d{1}{i},'accepted') && (i==length(d{1}) || strcmpi(d{1}{i+1}(1:3),'ICA'))
      acceptInd = [acceptInd i];
    end
  end
  for i=1:length(acceptInd)
    d{1} = [d{1}(1:acceptInd(i)+i-1); {'N/A'}; d{1}(acceptInd(i)+i:end)];
  end

  if rem(numel(d{1}), N)
    error('Invalid DSV file ''%s'': Varying number of delimiters per line.', ...
          filename);
  end
  d = reshape(d{1}, N, [])';
  allnum = true;
  for i = 1:numel(var)
    sts = true;
    dd = zeros(size(d, 1), 1);
    for j = 1:size(d, 1)
      if strcmp(d{j, i}, 'n/a')
        dd(j) = NaN;
      else
        dd(j) = str2double(d{j, i}); % i,j considered as complex
        if isnan(dd(j))
          sts = false;
          break
        end
      end
    end
    if sts
      x.(var{i}) = dd;
    else
      x.(var{i}) = d(:, i);
      allnum = false;
    end
  end

  if ~hdr && allnum
    x = struct2cell(x);
    x = [x{:}];
  end

end
